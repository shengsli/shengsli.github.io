<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>ppls lec12 w8b review</title>
<!-- 2019-05-21 Tue 22:05 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="sheng li" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" 						   type="text/css" 						   href="https://shengsli.github.io/css/style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">ppls lec12 w8b review</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Example: MPI Task Farm</a>
<ul>
<li><a href="#sec-1-1">1.1. Gist of task farm</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Send in standard mode</a></li>
<li><a href="#sec-3">3. Receive in standard mode</a></li>
<li><a href="#sec-4">4. Code</a></li>
<li><a href="#sec-5">5. Synchronization in MPI</a>
<ul>
<li><a href="#sec-5-1">5.1. blocking send and non-blocking send/receive</a>
<ul>
<li><a href="#sec-5-1-1">5.1.1. send</a></li>
<li><a href="#sec-5-1-2">5.1.2. receive</a></li>
<li><a href="#sec-5-1-3">5.1.3. Remarks</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6">6. Is it possible to be non-blocking and synchronous?</a></li>
<li><a href="#sec-7">7. Blocking communication semantics in MPI</a></li>
</ul>
</div>
</div>
<div class="post-info">
<p>
Created by sheng li on <span class="timestamp-wrapper"><span class="timestamp">&lt;2019-05-21 Tue 18:58&gt;</span></span>.
</p>
</div>
<p>
We talked about MPI primitives last time. We will look at how MPI primitives are used in task farm. We will look at another example, pipeline. We will also look at dynamic process spawning in MPI.
</p>
<ul class="org-ul">
<li>We will focus on MPI synchronization. 
</li>
</ul>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Example: MPI Task Farm</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>A task farm is bag-of-tasks in which all the tasks are known from the start.
</li>
<li>The challenge is to assign tasks dynamically to worker processes, to allow for the possibility that tasks may take much longer to compute that others. 
</li>
<li>To simplify the code, we assume that there are at least as many tasks as processes and that tasks and results are just integers.
</li>
<li>Tags are used to identify tasks and results. A special tag is used to indicate an "end of tasks" message. 
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Gist of task farm</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>With the assumption above, we can have 3 phases: 
<ol class="org-ol">
<li>one task for every worker
</li>
<li>demand driven phase
</li>
<li>no more new tasks, compute result, shut down everything
</li>
</ol>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Send in standard mode</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">int</span> <span style="color: #98fb98;">MPI_Send</span>(<span style="color: #7fffd4;">void</span> *<span style="color: #9acd32;">buf</span>,             <span style="color: #00cd66;">// </span><span style="color: #00cd66;">pointer</span>
             <span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">count</span>,             <span style="color: #00cd66;">// </span><span style="color: #00cd66;">size</span>
             <span style="color: #7fffd4;">MPI_Datatype</span> <span style="color: #9acd32;">datatype</span>, <span style="color: #00cd66;">// </span><span style="color: #00cd66;">type</span>
             <span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">dest</span>,              <span style="color: #00cd66;">// </span><span style="color: #00cd66;">destination process</span>
             <span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">tag</span>,               <span style="color: #00cd66;">// </span><span style="color: #00cd66;">must be non-negative</span>
             <span style="color: #7fffd4;">MPI_Comm</span> <span style="color: #9acd32;">comm</span>)         <span style="color: #00cd66;">// </span><span style="color: #00cd66;">communicator</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Receive in standard mode</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">int</span> <span style="color: #98fb98;">MPI_Recv</span>(<span style="color: #7fffd4;">void</span> *<span style="color: #9acd32;">buf</span>,
             <span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">count</span>,
             <span style="color: #7fffd4;">MPI_Datatype</span> <span style="color: #9acd32;">datatype</span>,
             <span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">source</span>,            <span style="color: #00cd66;">// </span><span style="color: #00cd66;">source process</span>
             <span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">tag</span>,
             <span style="color: #7fffd4;">MPI_Comm</span> <span style="color: #9acd32;">comm</span>,
             <span style="color: #7fffd4;">MPI_Status</span> *<span style="color: #9acd32;">status</span>)
</pre>
</div>
<ul class="org-ul">
<li><b>Non-determinism</b> (within a communicator): wild cards, <code>MPI_ANY_SOURCE</code>, <code>MPI_ANY_TAG</code>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Code</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #b0c4de;">#define</span> <span style="color: #9acd32;">MAX_TASKS</span> 100
<span style="color: #b0c4de;">#define</span> <span style="color: #9acd32;">NO_MORE_TASKS</span> MAX_TASKS+1
<span style="color: #b0c4de;">#define</span> <span style="color: #9acd32;">FARMER</span> 0
<span style="color: #7fffd4;">int</span> <span style="color: #98fb98;">main</span>(<span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">argc</span>, <span style="color: #7fffd4;">char</span> *<span style="color: #9acd32;">argv</span>)
{
    <span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">np</span>, <span style="color: #9acd32;">rank</span>;
    MPI_Init(&amp;argc, &amp;argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
    MPI_Comm_size(MPI_COMM_WORLD, &amp;np);
    <span style="color: #ffffff;">if</span> (rank == FARMER)
    {
        farmer(np-1);
    }
    <span style="color: #ffffff;">else</span>
    {
        worker();
    }
    MPI_Finalize();
}

<span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">farmer</span> (<span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">workers</span>)
{
    <span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">i</span>, <span style="color: #9acd32;">task</span>[MAX_TASKS], <span style="color: #9acd32;">result</span> [MAX_TASKS], <span style="color: #9acd32;">temp</span>, <span style="color: #9acd32;">tag</span>, <span style="color: #9acd32;">who</span>;
    <span style="color: #7fffd4;">MPI_Status</span> <span style="color: #9acd32;">status</span>;

    <span style="color: #ffffff;">for</span> (i=0; i&lt;workers; i++)
    {
        MPI_Send(task[i], 1, MPI_INT, i+1, i, MPI_COMM_WORLD);
    }

    <span style="color: #ffffff;">while</span> (i&lt;MAX_TASKS)
    {
        MPI_Recv(&amp;temp, 1, MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &amp;STATUS);
        who = status.STATUS.MPI_SOURCE;
        tag = status.MPI_TAG;
        result[tag] = temp;
        MPI_Send(&amp;task[i], 1, MPI_INT, who, i, MPI_COMM_WORLD);
        i++;
    }

    <span style="color: #ffffff;">for</span> (i=0; i&lt;workers; i++)
    {
        MPI_Recv(&amp;temp, 1, MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMMON_WORLD);
        who = status.MPI_SOURCE;
        tag = statUs.MPI_TAG;
        result[tag] = temp;
        MPI_Send(&amp;task[i], 1, MPI_INT, who, NO_MORE_TASKS, MPI_COMM_WORLD);
    }
}

<span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">worker</span> ()
{
    <span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">task</span>, <span style="color: #9acd32;">result</span>, <span style="color: #9acd32;">tag</span>;
    <span style="color: #7fffd4;">MPI_Status</span> <span style="color: #9acd32;">status</span>;
    MPI_Recv(&amp;task, 1, MPI_INT, FARMER, MPI_ANY_TAG, MPI_COMMON_WORLD, &amp;status);
    tag = status.MPI_TAG;

    <span style="color: #ffffff;">while</span> (tag != NO_MOE_TASKS)
    {
        result = somefunction(task);
        MPI_Send(&amp;result, 1, MPI_INT, FARMER, tag, MPI_COMM_WORLD);
        MPI_Recv(&amp;task, 1 MPI_INT, FARMER, MPI_ANY_TAG, MPI_COMM_WORLD, &amp;status);
        tag = status.MPI_TAG;
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Synchronization in MPI</h2>
<div class="outline-text-2" id="text-5">
<p>
MPI uses the term blocking and synchronization in a lightly unconventional way. 
</p>
<ul class="org-ul">
<li>Blocking happens between and MPI runtime and a process calling a communication function like send and receive. Blocking between process A and MPI runtime has nothing to do with process B. (see slide p155)
</li>
<li>Synchronization refers to what's between processes with MPI runtime hidden away. 
</li>
<li>MPI runtime is basically a matching process between send and receive. It's a complex implementation challenge. 
</li>
</ul>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> blocking send and non-blocking send/receive</h3>
<div class="outline-text-3" id="text-5-1">
</div><div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1"><span class="section-number-4">5.1.1</span> send</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>A blocking send completes only when it is safe to reuse the specified output buffer (because the data has been copied some where sage by the system).
</li>
<li>A process calling a non-blocking send continues immediately with unpredictable effects on the values actually sent. 
<ul class="org-ul">
<li>It gives you a handle of the communication to ask if the process has completed taking a copy of buffer.
</li>
<li>Programmers can choose to use the buffer without checking. 
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2"><span class="section-number-4">5.1.2</span> receive</h4>
<div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>Similarly, non-blocking receive allows calling process to continue immediately with similar issues concerning the values which appear tin the buffer. 
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-1-3" class="outline-4">
<h4 id="sec-5-1-3"><span class="section-number-4">5.1.3</span> Remarks</h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
To manage these effects, there are MPI operations for monitoring the progress of non-blocking communications. (effectively, to ask, "is it OK to use this variable now?")
</p>

<p>
The idea is that with careful use these can allow the process to get on with other useful work even before the user-space buffer has been safely stored. 
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Is it possible to be non-blocking and synchronous?</h2>
<div class="outline-text-2" id="text-6">
<p>
It is possible in the sense that a process can ask/check/test if the transfer of buffer is complete. 
</p>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Blocking communication semantics in MPI</h2>
<div class="outline-text-2" id="text-7">
<ol class="org-ol">
<li>Send

<p>
MPI provide 4 different blocking send operations, we consider the main 3 only. They vary in the level of synchronization they provide. Each makes different demands on the underlying communication protocol (i.e. the implementation).
</p>
<ol class="org-ol">
<li><code>MPI_Ssend</code>: Synchronous mode send is blocking and synchronous, only returning when a matching receive has been found.
</li>
<li><code>MPI_Send</code>: Standard mode send is blocking. Asynchronous when buffer is not full. Synchronous when buffer is full.
</li>
<li><code>MPI_Bsend</code>: is blocking and asynchronous. Most programs don't use. 
</li>
</ol>
</li>
<li>Receive
<ol class="org-ol">
<li><code>MPI_Recv</code>: is blocking and synchronous. It blocks until a matching message has been completely received into the buffer. 
</li>
</ol>
</li>
</ol>
</div>
</div>
</div>
</body>
</html>
